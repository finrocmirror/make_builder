#!/usr/bin/perl -w

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
# 
#----------------------------------------------------------------------
# \file    enum_strings_builder
#
# \author  Max Reichardt
#
# \date    2011-08-24
#
# Script to auto-generate port names for finroc modules in the build process.
# It operates on doxygen perlmod output.
#
# It creates a .cpp file with port names for all modules and groups that contain ports.
#----------------------------------------------------------------------

use strict;
use DoxyDocs;

my $classes = $::doxydocs->{classes};
my $files = $::doxydocs->{files};
my $namespaces = $::doxydocs->{namespaces};

my $output_filename = $ARGV[0] or die "Output filename not specified!\n";

unlink $output_filename;

my $output = "";

# Gets common prefix of enum constants
sub GetCommonEnumPrefix(@) {
    my @parts_list = ();
    my $result = "";
    foreach my $name (@_) {
        if ($name =~ /^e\u.*/) { # cut off leading e in any case
            $name = substr($name, 1); 
        }
        my @temp = split('_', $name);
        push @parts_list, \@temp;
    }
    for my $i (0..1000) {
        my $first_parts = $parts_list[0];
        my $part = @$first_parts[$i];
        foreach my $parts (@parts_list) {
            if (@$parts <= $i || !(@$parts[$i] eq $part)) {
                return $result;
            }
        }
        $result = $result . $part . "_";
    }
    return $result;
}

# Performs 'natural' formatting (code from original description_builder)
sub FormatEnum {
    my $enum_value = shift;
    my @words = split ("_", $enum_value);
    @words = map lc, @words;
    @words = map ucfirst, @words;
    $enum_value = join (" ", @words);
    return $enum_value;
}

# Takes namespace (&class) name, enum name and 'values' array and writes code to C++ file
sub ProcessEnum {
    my $namespace_name = shift;
    my $enum_name = shift;
    my $values = shift;

    if ((!defined($values)) or @$values <= 1 or substr($enum_name, 0, 1) eq "@") {
        return;
    }

    my $postfix = lc($namespace_name . "::" . $enum_name);
    $postfix =~ s/::/_/g;

    my @names = ();
    foreach my $value (@$values) {
        push @names, $value->{name};
    }
    my $common_prefix = GetCommonEnumPrefix(@names);
    if (@names <= 1) {
        $common_prefix = $names[0] =~ /^e\u.*/ ? "e" : "";
    }
    if ($names[-1] =~ /_DIMENSION$/) { # remove any last _DIMENSION element
        pop(@names);
    }

    foreach my $name (@names)
    {
        die sprintf "Illegal enum declaration { %s }\n", join ", ", @names unless length $name > length $common_prefix;
	return unless length $name > length $common_prefix;
    }

    $output .= sprintf "const char *strings_%s[] = {\n  \"%s\"\n};\n", $postfix, join "\",\n  \"", map { FormatEnum(substr($_, length $common_prefix)) } @names;
    $output .= sprintf "const tEnumStrings enum_strings_%s = { strings_%s, %d };\n", $postfix, $postfix, scalar @names;
    $output .= sprintf "__attribute__ ((init_priority (101))) static tRegisterEnumStrings init_strings_%s(\"%s::%s\", enum_strings_%s);\n", $postfix, $namespace_name, $enum_name, $postfix;
    $output .= sprintf "\n";
}

# generate code for outer-class enum strings
foreach my $namespace (@$namespaces) {
    my $namespace_name = $namespace->{name};
    my $enums = $namespace->{enums}->{members};
    foreach my $enum (@$enums) {
        my $enum_name = $enum->{name};
        my $values = $enum->{values};
        ProcessEnum($namespace_name, $enum_name, $values);
    }
}

# generate code for enums defined in classes
foreach my $class (@$classes) {
    my $members = $class->{public_typedefs}->{members};
    my $class_name = $class->{name};
    foreach my $member (@$members) {
        my $kind = $member->{kind};
        my $name = $member->{name};
        if (!($kind eq "enum") or (length($name) <= 0)) {
            next;
        }
        my $values = $member->{values};
        ProcessEnum($class_name, $name, $values);
    }
}

open OUTPUT, ">$output_filename" or die "Could not open '$output_filename' for writing: $!\n";

# generate header comment
printf OUTPUT "/*\n";
printf OUTPUT " * This file was automatically generated from the source file%s\n", scalar @$files > 1 ? "s" : "";
printf OUTPUT " * %s\n", join "\n * ", (map { $_->{'name'} } @$files);
printf OUTPUT " * using enum_strings_builder.\n";
printf OUTPUT " * This code is released under the same license as the source files.\n";
printf OUTPUT " */\n\n";

# namespace
printf OUTPUT "namespace make_builder\n{\nnamespace generated\n{\n\n";

print OUTPUT $output;

printf OUTPUT "}\n}\n";

close OUTPUT;
